{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red127\green0\blue85;\red63\green127\blue95;\red0\green0\blue192;
\red106\green62\blue62;\red42\green0\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs22 \cf2 import\cf0  java.io.*;\
\cf2 public\cf0  \cf2 class\cf0  DemoMergeSort \{\
	\cf3 //define an array as private\cf0 \
	\cf2 private\cf0  \cf2 int\cf0  [] \cf4 inputArr\cf0 ;\
	\cf3 //define size of array as private\cf0 \
	\cf2 private\cf0  \cf2 int\cf0  \cf4 size\cf0 ;\
	\cf3 //Create Buffered Reader variable\cf0 \
	\cf2 private\cf0  BufferedReader \cf4 br\cf0 ;\
	\cf3 //Define sorted result\cf0 \
	\cf2 public\cf0  \cf2 int\cf0  [] \cf4 result\cf0  = \cf2 new\cf0  \cf2 int\cf0  [\cf4 size\cf0 ];\
	\cf3 //construct a constructor 	\cf0 \
	\cf2 public\cf0  DemoMergeSort(\cf2 int\cf0  \cf5 inputSize\cf0 )\{\
		\cf4 size\cf0  = \cf5 inputSize\cf0 ;\
		\cf3 //\ul initialise\ulnone  input array and buffered reader variable to take input from console\cf0 \
		\cf4 inputArr\cf0  = \cf2 new\cf0  \cf2 int\cf0 [\cf4 size\cf0 ];\
		\cf4 br\cf0  = \cf2 new\cf0  BufferedReader(\cf2 new\cf0  InputStreamReader(System.\cf4 in\cf0 ));\
	\}\
	\cf3 //take input to be \ul mergersort\ulnone  from console\cf0 \
	\cf2 public\cf0  \cf2 int\cf0  [] takeInput()\{\
		System.\cf4 out\cf0 .println(\cf6 "Enter Unsorted input of size "\cf0 +\cf4 size\cf0 );\
		System.\cf4 out\cf0 .println();\
		\cf2 int\cf0  \cf5 iCount\cf0  = 0;\
		String \cf5 strConsoleInput\cf0 ;\
		\cf2 try\cf0 \{\
			\cf2 while\cf0 (\cf5 iCount\cf0  < \cf4 size\cf0 )\{\
				\cf5 strConsoleInput\cf0  = (String)\cf4 br\cf0 .readLine();\
				\cf4 inputArr\cf0 [\cf5 iCount\cf0 ] = Integer.parseInt(\cf5 strConsoleInput\cf0 );\
				\cf5 iCount\cf0 ++;\
			\}\
			\cf2 return\cf0  \cf4 inputArr\cf0 ;\
		\}\
		\cf2 catch\cf0 (IOException \cf5 e\cf0 )\
		\{\
			System.\cf4 out\cf0 .println(\cf5 e\cf0 );\
			\cf2 return\cf0  \cf4 inputArr\cf0 ;\
		\}				\
	\}	\
	\
	\cf2 public\cf0  \cf2 int\cf0  [] merge(\cf2 int\cf0 []\cf5 L\cf0 , \cf2 int\cf0  []\cf5 R\cf0 , \cf2 int\cf0  [] \cf5 A\cf0  )\{\
		\cf2 int\cf0  \cf5 i\cf0  = 0;\
		\cf2 int\cf0  \cf5 j\cf0  = 0;\
		\cf2 int\cf0  \cf5 k\cf0  = 0;\
		\cf2 int\cf0  \cf5 nL\cf0  = \cf5 L\cf0 .\cf4 length\cf0 ;\
		\cf2 int\cf0  \cf5 nR\cf0  = \cf5 R\cf0 .\cf4 length\cf0 ;\
		\cf2 while\cf0 ((\cf5 i\cf0  < \cf5 nL\cf0  ) && (\cf5 j\cf0  < \cf5 nR\cf0 ))\{\
			\cf2 if\cf0 (\cf5 L\cf0 [\cf5 i\cf0 ] <= \cf5 R\cf0 [\cf5 j\cf0 ])\{\
				\cf5 A\cf0 [\cf5 k\cf0 ] = \cf5 L\cf0 [\cf5 i\cf0 ];\
				\cf5 i\cf0 ++;\
				\cf5 k\cf0 ++;\
			\}\
			\cf2 else\cf0 \{\
				\cf5 A\cf0 [\cf5 k\cf0 ] = \cf5 R\cf0 [\cf5 j\cf0 ];\
				\cf5 j\cf0 ++;\
				\cf5 k\cf0 ++;\
			\}\
		\}\
		\cf2 while\cf0 (\cf5 i\cf0  < \cf5 nL\cf0 )\{\
			\cf5 A\cf0 [\cf5 k\cf0 ] = \cf5 L\cf0 [\cf5 i\cf0 ];\
			\cf5 i\cf0 ++;\
			\cf5 k\cf0 ++;\
		\}\
		\cf2 while\cf0 (\cf5 j\cf0  < \cf5 nR\cf0 )\{\
			\cf5 A\cf0 [\cf5 k\cf0 ] = \cf5 R\cf0 [\cf5 j\cf0 ];\
			\cf5 j\cf0 ++;\
			\cf5 k\cf0 ++;\
		\}\
		\cf2 return\cf0  \cf5 A\cf0 ;\
	\}\
	\cf3 //Define MergeSort\cf0 \
	\cf2 public\cf0  \cf2 void\cf0  MergeSort(\cf2 int\cf0  [] \cf5 A\cf0 )\{		\
		\cf2 if\cf0 (\cf5 A\cf0 .\cf4 length\cf0  < 2)\
			\cf2 return\cf0 ;\
		\cf2 int\cf0  \cf5 start\cf0  = 0;\
		\cf2 int\cf0  \cf5 end\cf0  = \cf5 A\cf0 .\cf4 length\cf0 ;\
		\cf2 int\cf0  \cf5 mid\cf0  = (\cf5 start\cf0  + \cf5 end\cf0 )/2;\
		\cf3 //Create new array as left and Right\cf0 \
		\cf2 int\cf0  [] \cf5 Left\cf0  = \cf2 new\cf0  \cf2 int\cf0 [\cf5 mid\cf0 ];\
		\cf2 int\cf0  [] \cf5 Right\cf0  = \cf2 new\cf0  \cf2 int\cf0 [\cf5 end\cf0 -\cf5 mid\cf0 ];		\
		\cf3 //Create copy of A into left\cf0 \
		\cf2 for\cf0 (\cf2 int\cf0  \cf5 iLCount\cf0  = 0; \cf5 iLCount\cf0  < \cf5 mid\cf0 ; \cf5 iLCount\cf0 ++)\{\
			\cf5 Left\cf0 [\cf5 iLCount\cf0 ] = \cf5 A\cf0 [\cf5 iLCount\cf0 ];\
		\}\
		\cf3 //Create copy of A into Right\cf0 \
		\cf2 for\cf0 (\cf2 int\cf0  \cf5 iRCount\cf0  = 0; \cf5 iRCount\cf0  < \cf5 Right\cf0 .\cf4 length\cf0 ; \cf5 iRCount\cf0 ++)\{\
			\cf5 Right\cf0 [\cf5 iRCount\cf0 ] = \cf5 A\cf0 [\cf5 mid\cf0 ];\
			\cf5 mid\cf0 ++;\
		\}\
		\cf3 //\ul recurrsive\ulnone  call of MergerSort for Left\cf0 \
		MergeSort(\cf5 Left\cf0 );\
		MergeSort(\cf5 Right\cf0 );\
		\cf4 result\cf0  = merge(\cf5 Left\cf0 ,\cf5 Right\cf0 ,\cf5 A\cf0 );				\
	\}\
	\cf3 //print array\cf0 \
	\cf2 public\cf0  \cf2 void\cf0  displaySortedArr()\{	\
		System.\cf4 out\cf0 .print(\cf6 "Sorted Out put is as: "\cf0 );\
		\cf2 for\cf0 (\cf2 int\cf0  \cf5 i\cf0  = 0; \cf5 i\cf0  < \cf4 result\cf0 .\cf4 length\cf0 ; \cf5 i\cf0 ++)\{\
			System.\cf4 out\cf0 .print(\cf4 result\cf0 [\cf5 i\cf0 ]+\cf6 ", "\cf0 );\
		\}\
	\}\
\}}